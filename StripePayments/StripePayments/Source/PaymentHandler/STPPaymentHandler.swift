//
//  STPPaymentHandler.swift
//  StripePayments
//
//  Created by Cameron Sabol on 5/10/19.
//  Copyright Â© 2019 Stripe, Inc. All rights reserved.
//

import AuthenticationServices
import Foundation
import PassKit
import SafariServices
@_spi(STP) import StripeCore

#if canImport(Stripe3DS2)
import Stripe3DS2
#endif

/// `STPPaymentHandlerActionStatus` represents the possible outcomes of requesting an action by `STPPaymentHandler`. An action could be confirming and/or handling the next action for a PaymentIntent.
@objc public enum STPPaymentHandlerActionStatus: Int {
    /// The action succeeded.
    case succeeded
    /// The action was cancelled by the cardholder/user.
    case canceled
    /// The action failed. See the error code for more details.
    case failed
}

/// Error codes generated by `STPPaymentHandler`
@objc public enum STPPaymentHandlerErrorCode: Int {
    /// Indicates that the action requires an authentication method not recognized or supported by the SDK.
    @objc(STPPaymentHandlerUnsupportedAuthenticationErrorCode)
    case unsupportedAuthenticationErrorCode

    /// Indicates that the action requires an authentication app, but either the app is not installed or the request to switch to the app was denied.
    @objc(STPPaymentHandlerRequiredAppNotAvailableErrorCode)
    case requiredAppNotAvailable

    /// Attach a payment method to the PaymentIntent or SetupIntent before using `STPPaymentHandler`.
    @objc(STPPaymentHandlerRequiresPaymentMethodErrorCode)
    case requiresPaymentMethodErrorCode

    /// The PaymentIntent or SetupIntent status cannot be resolved by `STPPaymentHandler`.
    @objc(STPPaymentHandlerIntentStatusErrorCode)
    case intentStatusErrorCode

    /// The action timed out.
    @objc(STPPaymentHandlerTimedOutErrorCode)
    case timedOutErrorCode

    /// There was an error in the Stripe3DS2 SDK.
    @objc(STPPaymentHandlerStripe3DS2ErrorCode)
    case stripe3DS2ErrorCode

    /// The transaction did not authenticate (e.g. user entered the wrong code).
    @objc(STPPaymentHandlerNotAuthenticatedErrorCode)
    case notAuthenticatedErrorCode

    /// `STPPaymentHandler` does not support concurrent actions.
    @objc(STPPaymentHandlerNoConcurrentActionsErrorCode)
    case noConcurrentActionsErrorCode

    /// Payment requires a valid `STPAuthenticationContext`.  Make sure your presentingViewController isn't already presenting.
    @objc(STPPaymentHandlerRequiresAuthenticationContextErrorCode)
    case requiresAuthenticationContextErrorCode

    /// There was an error confirming the Intent.
    /// Inspect the `paymentIntent.lastPaymentError` or `setupIntent.lastSetupError` property.
    @objc(STPPaymentHandlerPaymentErrorCode)
    case paymentErrorCode

    /// The provided PaymentIntent of SetupIntent client secret does not match the expected pattern for client secrets.
    /// Make sure that your server is returning the correct value and that is being passed to `STPPaymentHandler`.
    @objc(STPPaymentHandlerInvalidClientSecret)
    case invalidClientSecret

    /// The payment method requires a return URL and one was not provided. Your integration should provide one in your `STPPaymentIntentConfirmParams`/`STPSetupIntentConfirmParams` object if you call `STPPaymentHandler.confirm...` or when you call  `STPPaymentHandler.handleNextAction`.
    @objc(STPPaymentHandlerMissingReturnURL)
    case missingReturnURL

    /// The SDK encountered an unexpected error, indicating a problem with the SDK or the Stripe API.
    @objc(STPPaymentHandlerUnexpectedErrorCode)
    case unexpectedErrorCode
}

/// Completion block typedef for use in `STPPaymentHandler` methods for Payment Intents.
public typealias STPPaymentHandlerActionPaymentIntentCompletionBlock = (
    STPPaymentHandlerActionStatus, STPPaymentIntent?, NSError?
) -> Void
/// Completion block typedef for use in `STPPaymentHandler` methods for Setup Intents.
public typealias STPPaymentHandlerActionSetupIntentCompletionBlock = (
    STPPaymentHandlerActionStatus, STPSetupIntent?, NSError?
) -> Void

let missingReturnURLErrorMessage = "The payment method requires a return URL and one was not provided. Your integration should provide one in your `STPPaymentIntentConfirmParams`/`STPSetupIntentConfirmParams` object if you call `STPPaymentHandler.confirm...` or when you call  `STPPaymentHandler.handleNextAction`."

/// `STPPaymentHandler` is a utility class that confirms PaymentIntents/SetupIntents and handles any authentication required, such as 3DS1/3DS2 for Strong Customer Authentication.
/// It can present authentication UI on top of your app or redirect users out of your app (to e.g. their banking app).
/// - seealso: https://stripe.com/docs/payments/3d-secure
public class STPPaymentHandler: NSObject {
    /// The error domain for errors in `STPPaymentHandler`.
    @objc public static let errorDomain = "STPPaymentHandlerErrorDomain"

    /// These indicate a programming error in STPPaymentHandler. They are separate from the NSErrors vended to merchants; these errors are only reported to analytics and do not get vended to users of this class.
    enum InternalError: Error {
        case invalidState
    }

    internal var currentAction: STPPaymentHandlerActionParams?
    /// YES from when a public method is first called until its associated completion handler is called.
    /// This property guards against simultaneous usage of this instance; only one "next action" can be handled at a time per instance.
    /// Using instance-based state allows multiple `STPPaymentHandler` instances to process payments concurrently.
    var isProcessing = false
    var safariViewController: SFSafariViewController?
    var asWebAuthenticationSession: ASWebAuthenticationSession?

    /// The globally shared instance of `STPPaymentHandler`.
    @objc public static let sharedHandler: STPPaymentHandler = STPPaymentHandler()

    /// The globally shared instance of `STPPaymentHandler`.
    @objc
    public class func shared() -> STPPaymentHandler {
        return STPPaymentHandler.sharedHandler
    }

    @_spi(STP) public init(
        apiClient: STPAPIClient = .shared,
        threeDSCustomizationSettings: STPThreeDSCustomizationSettings =
            STPThreeDSCustomizationSettings()
    ) {
        self.apiClient = apiClient
        self.threeDSCustomizationSettings = threeDSCustomizationSettings
        super.init()
    }

    /// By default `sharedHandler` initializes with STPAPIClient.shared.
    @objc public var apiClient: STPAPIClient

    /// Customizable settings to use when performing 3DS2 authentication.
    /// Note: Configure this before calling any methods.
    /// Defaults to `STPThreeDSCustomizationSettings()`.
    @objc public var threeDSCustomizationSettings: STPThreeDSCustomizationSettings

    internal var _simulateAppToAppRedirect: Bool = false

    /// When this flag is enabled, STPPaymentHandler will confirm certain PaymentMethods using
    /// Safari instead of SFSafariViewController. If you'd like to use this in your own
    /// testing or Continuous Integration platform, please see the IntegrationTester app
    /// for usage examples.
    ///
    /// Note: This flag is only intended for development, and only impacts payments made with testmode keys.
    /// Setting this to `true` with a livemode key will fail.
    @objc public var simulateAppToAppRedirect: Bool
    {
        get {
            _simulateAppToAppRedirect && STPAPIClient.shared.isTestmode
        }
        set {
            _simulateAppToAppRedirect = newValue
        }
    }

    internal var _redirectShim: ((URL, URL?, Bool) -> Void)?
    internal var isInProgress: Bool {
        return isProcessing
    }
    internal var analyticsClient: STPAnalyticsClient = .sharedClient
    /// Date at which `confirm` or `handleNextAction` is called. Used to report how long the call took.
    internal var startTime: Date? {
        didSet {
            actionID = startTime == nil ? nil : UUID().uuidString
        }
    }
    /// A uuid unique to a given `confirm` or `handleNextAction` call, so that we can group together all the analytics sent during a confirmation / next action handling.
    /// Note that Session ID is not good enough, since a single session may have multiple calls to confirm.
    internal var actionID: String?

    /// Registry of authentication handlers for different action types.
    /// This allows the payment handler to delegate authentication logic to focused, testable components.
    private lazy var authenticationHandlerRegistry = AuthenticationHandlerRegistry()

    // MARK: - PaymentIntent APIs

    /// Confirms the PaymentIntent using the provided `params` and handles any next actions required to authenticate the PaymentIntent.
    @objc(confirmPaymentIntentWithParams:authenticationContext:completion:)
    public func confirmPaymentIntent(
        params: STPPaymentIntentConfirmParams,
        authenticationContext: STPAuthenticationContext,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        _confirmPaymentIntentImpl(params: params, authenticationContext: authenticationContext, completion: completion)
    }

    /// Confirms the PaymentIntent (async version).
    public func confirmPaymentIntent(
        params: STPPaymentIntentConfirmParams,
        authenticationContext: STPAuthenticationContext
    ) async -> (STPPaymentHandlerActionStatus, STPPaymentIntent?, Error?) {
        await withCheckedContinuation { continuation in
            confirmPaymentIntent(params: params, authenticationContext: authenticationContext) { status, paymentIntent, error in
                continuation.resume(returning: (status, paymentIntent, error))
            }
        }
    }

    @_spi(SharedPaymentToken) public func handleNextAction(
        forPaymentHashedValue hashedValue: String,
        with authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        _handleNextActionForHashedValueImpl(hashedValue: hashedValue, authenticationContext: authenticationContext, returnURL: returnURL, completion: completion)
    }
    var subhandler: STPPaymentHandler?

    /// Handles any `nextAction` required to authenticate the PaymentIntent (async version).
    public func handleNextAction(
        paymentIntentClientSecret: String,
        authenticationContext: STPAuthenticationContext,
        returnURL: String?
    ) async -> (STPPaymentHandlerActionStatus, STPPaymentIntent?, NSError?) {
        await withCheckedContinuation { continuation in
            handleNextAction(paymentIntentClientSecret: paymentIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL) { status, paymentIntent, error in
                continuation.resume(returning: (status, paymentIntent, error))
            }
        }
    }

    /// Handles any `nextAction` required to authenticate the PaymentIntent.
    @objc(handleNextActionForPaymentIntent:authenticationContext:returnURL:completion:)
    public func handleNextAction(
        paymentIntentClientSecret: String,
        authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        _handleNextActionForPaymentIntentClientSecretImpl(clientSecret: paymentIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL, completion: completion)
    }

    @_spi(STP) public func handleNextAction(
        for paymentIntent: STPPaymentIntent,
        with authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        shouldSendAnalytic: Bool = true,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        _handleNextActionForPaymentIntentImpl(paymentIntent: paymentIntent, authenticationContext: authenticationContext, returnURL: returnURL, shouldSendAnalytic: shouldSendAnalytic, completion: completion)
    }

    // MARK: - SetupIntent APIs

    /// Confirms the SetupIntent using the provided parameters.
    @objc(confirmSetupIntentWithParams:authenticationContext:completion:)
    public func confirmSetupIntent(
        params: STPSetupIntentConfirmParams,
        authenticationContext: STPAuthenticationContext,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        _confirmSetupIntentImpl(params: params, authenticationContext: authenticationContext, completion: completion)
    }

    /// Confirms the SetupIntent (async version).
    public func confirmSetupIntent(
        params: STPSetupIntentConfirmParams,
        authenticationContext: STPAuthenticationContext
    ) async -> (STPPaymentHandlerActionStatus, STPSetupIntent?, Error?) {
        await withCheckedContinuation { continuation in
            confirmSetupIntent(params: params, authenticationContext: authenticationContext) { status, setupIntent, error in
                continuation.resume(returning: (status, setupIntent, error))
            }
        }
    }

    /// Handles any `nextAction` required to authenticate the SetupIntent (async version).
    public func handleNextAction(
        setupIntentClientSecret: String,
        authenticationContext: STPAuthenticationContext,
        returnURL: String?
    ) async -> (STPPaymentHandlerActionStatus, STPSetupIntent?, Error?) {
        await withCheckedContinuation { continuation in
            handleNextAction(setupIntentClientSecret: setupIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL) { status, setupIntent, error in
                continuation.resume(returning: (status, setupIntent, error))
            }
        }
    }

    /// Handles any `nextAction` required to authenticate the SetupIntent.
    @objc(handleNextActionForSetupIntent:authenticationContext:returnURL:completion:)
    public func handleNextAction(
        setupIntentClientSecret: String,
        authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        _handleNextActionForSetupIntentClientSecretImpl(clientSecret: setupIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL, completion: completion)
    }

    @_spi(STP) public func handleNextAction(
        for setupIntent: STPSetupIntent,
        with authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        shouldSendAnalytic: Bool = true,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        _handleNextActionForSetupIntentImpl(setupIntent: setupIntent, authenticationContext: authenticationContext, returnURL: returnURL, shouldSendAnalytic: shouldSendAnalytic, completion: completion)
    }

    // MARK: - Private Helpers

    func _handleNextAction(
        forPayment paymentIntent: STPPaymentIntent,
        with authenticationContext: STPAuthenticationContext,
        returnURL returnURLString: String?,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        guard paymentIntent.status != .requiresPaymentMethod else {
            // The caller forgot to attach a paymentMethod.
            completion(
                .failed,
                paymentIntent,
                _error(for: .requiresPaymentMethodErrorCode)
            )
            return
        }

        let action = STPPaymentHandlerPaymentIntentActionParams(
            apiClient: apiClient,
            authenticationContext: authenticationContext,
            threeDSCustomizationSettings: threeDSCustomizationSettings,
            paymentIntent: paymentIntent,
            returnURL: returnURLString
        ) {  [weak self] status, resultPaymentIntent, error in
            guard let self else {
                return
            }
            self.currentAction = nil
            completion(status, resultPaymentIntent, error)
        }
        currentAction = action
        let requiresAction = _handlePaymentIntentStatus(forAction: action)
        if requiresAction {
            _handleAuthenticationForCurrentAction()
        }
    }

    func _handleNextAction(
        for setupIntent: STPSetupIntent,
        with authenticationContext: STPAuthenticationContext,
        returnURL returnURLString: String?,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        guard setupIntent.status != .requiresPaymentMethod else {
            // The caller forgot to attach a paymentMethod.
            completion(
                .failed,
                setupIntent,
                _error(for: .requiresPaymentMethodErrorCode)
            )
            return
        }

        let action = STPPaymentHandlerSetupIntentActionParams(
            apiClient: apiClient,
            authenticationContext: authenticationContext,
            threeDSCustomizationSettings: threeDSCustomizationSettings,
            setupIntent: setupIntent,
            returnURL: returnURLString
        ) { [weak self] status, resultSetupIntent, resultError in
            guard let self else {
                return
            }
            self.currentAction = nil
            completion(status, resultSetupIntent, resultError)
        }
        currentAction = action
        let requiresAction = _handleSetupIntentStatus(forAction: action)
        if requiresAction {
            _handleAuthenticationForCurrentAction()
        }
    }

    func _handleAuthenticationForCurrentAction() {
        guard let currentAction else {
            stpAssertionFailure("Calling _handleAuthenticationForCurrentAction without a currentAction")
            let errorAnalytic = ErrorAnalytic(event: .unexpectedPaymentHandlerError, error: InternalError.invalidState, additionalNonPIIParams: ["error_message": "Calling _handleAuthenticationForCurrentAction without a currentAction"])
            analyticsClient.log(analytic: errorAnalytic, apiClient: apiClient)
            return
        }
        guard let authenticationAction = currentAction.nextAction() else {
            stpAssertionFailure("Calling _handleAuthenticationForCurrentAction without a next action!")
            currentAction.complete(
                with: .failed,
                error: _error(for: .unexpectedErrorCode, loggingSafeErrorMessage: "Calling _handleAuthenticationForCurrentAction without a next action!")
            )
            return
        }

        // Try to handle the action using the registry of authentication handlers
        if authenticationHandlerRegistry.handle(
            action: authenticationAction,
            currentAction: currentAction,
            paymentHandler: self
        ) {
            return
        }

        // Handle unknown/unsupported action types
        currentAction.complete(
            with: STPPaymentHandlerActionStatus.failed,
            error: self._error(
                for: .unsupportedAuthenticationErrorCode,
                loggingSafeErrorMessage: "Unknown authentication action type: \(authenticationAction.type)"
            )
        )
    }

    func callContextDidDismissIfNeeded(_ context: (any STPAuthenticationContext)?, _ viewController: UIViewController?) {
        guard let context, let viewController else { return }

        if context.responds(
            to: #selector(STPAuthenticationContext.authenticationContextDidDismiss(_:))
        )
        {
            context.authenticationContextDidDismiss?(viewController)
        }
    }
}

// MARK: - Deprecated public funcs

extension STPPaymentHandler {
    @available(*, deprecated, renamed: "confirmPaymentIntent(params:authenticationContext:completion:)", message: "")
    @objc(confirmPayment:withAuthenticationContext:completion:)
    public func confirmPayment(
        _ paymentParams: STPPaymentIntentParams,
        with authenticationContext: STPAuthenticationContext,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        confirmPaymentIntent(params: paymentParams, authenticationContext: authenticationContext, completion: completion)
    }

    @available(*, deprecated, renamed: "confirmSetupIntent(params:authenticationContext:completion:)", message: "")
    @objc(confirmSetupIntent:withAuthenticationContext:completion:)
    public func confirmSetupIntent(
        _ setupIntentConfirmParams: STPSetupIntentConfirmParams,
        with authenticationContext: STPAuthenticationContext,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        confirmSetupIntent(params: setupIntentConfirmParams, authenticationContext: authenticationContext, completion: completion)
    }

    @available(*, deprecated, renamed: "handleNextAction(paymentIntentClientSecret:authenticationContext:completion:)", message: "")
    @objc(handleNextActionForPayment:withAuthenticationContext:returnURL:completion:)
    public func handleNextAction(
        forPayment paymentIntentClientSecret: String,
        with authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        completion: @escaping STPPaymentHandlerActionPaymentIntentCompletionBlock
    ) {
        handleNextAction(paymentIntentClientSecret: paymentIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL, completion: completion)
    }

    @available(*, deprecated, renamed: "handleNextAction(setupIntentClientSecret:authenticationContext:completion:)", message: "")
    @objc(handleNextActionForSetupIntent:withAuthenticationContext:returnURL:completion:)
    public func handleNextAction(
        forSetupIntent setupIntentClientSecret: String,
        with authenticationContext: STPAuthenticationContext,
        returnURL: String?,
        completion: @escaping STPPaymentHandlerActionSetupIntentCompletionBlock
    ) {
        handleNextAction(setupIntentClientSecret: setupIntentClientSecret, authenticationContext: authenticationContext, returnURL: returnURL, completion: completion)
    }
}
