---
description: 
globs: 
alwaysApply: true
---
# Stripe iOS SDK Coding Standards

## General Philosophy

- **Simplicity Over Complexity**: Always favor simple, straightforward, and readable solutions. Avoid premature optimizations or overly complex abstractions unless the problem's requirements explicitly demand them.
- **Self-Documenting Code**: Minimize comments within the code. Instead, focus on writing self-documenting code by using clear, descriptive names for variables, functions, and components. The code itself should be easy to understand. 

## Swift-Specific Guidelines

### Naming Conventions

- Use descriptive names that lean towards clarity over compactness
- For public APIs, use clear, self-documenting names that follow Apple's API Design Guidelines
- Use camelCase for variables, methods, and properties
- Use PascalCase for types (structs, classes, enums, protocols)

### Code Structure and Formatting

- **Indentation**: Use 4 spaces (no tabs) - follow the project's `.swift-format` configuration
- **Line length**: Maximum 120 characters (per `.swift-format` config)
- **Empty lines**: Maximum 1 consecutive empty line
- **Braces**: Opening braces on same line, closing braces on new line

If a function signature or function call approaches or exceeds the maximum line lenght, a new line should be added at the start of every parameter.

Example:
```swift
// Good object
struct User {
    let id: String
    let firstName: String
    let lastName: String
    let dateOfBirth: Date
    let avatarUrl: URL

    // Good function decleration
    init(
        id: String,
        firstName: String,
        lastName: String,
        dateOfBirth: Date,
        avatarUrl: URL
    ) {
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.dateOfBirth = dateOfBirth
        self.avatarUrl = avatarUrl
    }
}

// Good function call
let john = User(
    id: "12345",
    firstName: "John",
    lastName: "Doe",
    dateOfBirth: Date(),
    avatarUrl: URL(string: "https://example.com/avatar.jpg")!
)
```

### Control Flow

- Place `else` and `else if` on same line as preceding closing brace
- Each return statement should be on separate line for debugging ease
- Use ternary operators sparingly and only for simple conditions
- Switch statements on enums should be exhaustive; avoid `default` when possible

Example:
```swift
// Good if / else
if condition {
    return value
} else if otherCondition {
    return otherValue
} else {
    return defaultValue
}

// Good switch
switch side {
case .up, .down:
    return .vertical
case .left, .right:
    return .horizontal
}

// Good ternary usage
let type = isCard ? "card" : "unknown"

// Avoid complex ternary
let result = (someComplexCondition && anotherCondition) ? veryLongMethodCall() : anotherComplexOperation()
```

### Auto Layout and UI Programming

- **Always set** `translatesAutoresizingMaskIntoConstraints = false` when using programmatic layout
- **Use semantic spacing constants** (like `Constants.contentSpacing`) rather than magic numbers

Example:

```swift
enum Constants {
    static let contentSpacing: CGFloat = 16.0
}
```

- **Handle dynamic type** and accessibility considerations
- **Group related constraints** together for better readability

Example:

```swift
// Good
final class AddButton: UIControl {

    private lazy var textLabel: UILabel = {
        let label = UILabel()
        label.text = String.Localized.add_a_payment_method
        label.numberOfLines = 0
        label.textColor = tintColor
        label.font = LinkUI.font(forTextStyle: .bodyEmphasized)
        label.adjustsFontForContentSizeCategory = true
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()

    override var isHighlighted: Bool {
        didSet {
            update()
        }
    }

    init() {
        super.init(frame: .zero)

        isAccessibilityElement = true
        accessibilityTraits = .button
        accessibilityLabel = textLabel.text
        directionalLayoutMargins = Cell.Constants.margins

        setupUI()
        update()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        if self.point(inside: point, with: event) {
            return self
        }

        return nil
    }

    override func tintColorDidChange() {
        super.tintColorDidChange()
        self.textLabel.textColor = tintColor
    }

    private func setupUI() {
        addSubview(textLabel)

        NSLayoutConstraint.activate([
            textLabel.topAnchor.constraint(equalTo: layoutMarginsGuide.topAnchor),
            textLabel.bottomAnchor.constraint(equalTo: layoutMarginsGuide.bottomAnchor),
            textLabel.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor),
            textLabel.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor),
        ])
    }

    private func update() {
        if isHighlighted {
            textLabel.alpha = 0.7
            backgroundColor = .linkSurfaceTertiary
        } else {
            textLabel.alpha = 1
            backgroundColor = .clear
        }
    }

}
```

### Memory Management and Properties

- Use `let` over `var` when values don't change. Strive for immutability.
- Use `weak` references to break retain cycles
- Use `private(set)` for properties that should be readable but not writable externally
- Use lazy initialization for expensive computations

### Error Handling

- Use Swift's error handling patterns (`throws`, `Result` types)
- Provide meaningful error messages and context
- Handle edge cases gracefully with appropriate guard statements

### Stripe-Specific Patterns

- Use `@_spi(STP)` for internal Swift APIs that need to be shared across modules
- Follow established theming/appearance patterns (see `PaymentSheet.Appearance`)
- Maintain backward compatibility for public APIs
- Use appropriate access levels (`internal`, `private`, `fileprivate`)
- Follow the existing module structure and organization
- Localize strings that are displayed in UI elements with `STPLocalizedString`. The first parameter is the string to be localized, and the second parameter is a description of the string. For example:

```swift
STPLocalizedString(
    "Add a payment method",
    "Text for a button that, when tapped, displays another screen where the customer can add a new payment method"
)
```

This comprehensive guide should be followed for all new code and when refactoring existing code. When in doubt, follow the patterns established in the existing codebase and prioritize clarity and maintainability.
